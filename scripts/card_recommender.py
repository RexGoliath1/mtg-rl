#!/usr/bin/env python3
"""
MTG Card Recommender — EDHREC-inspired card suggestions.

Serves a dark-themed web UI (matching the embedding quiz) where users paste
a decklist in Moxfield/Archidekt/Arena/MTGGoldfish format and get a 3x3 grid
of recommended cards with Scryfall images, mechanics tags, and similarity scores.

Usage:
    python3 scripts/card_recommender.py
    python3 scripts/card_recommender.py --port 8000

Then open http://localhost:8000 in your browser.

Requirements:
    pip install numpy h5py

Data:
    data/card_mechanics_commander.h5  (generated by precompute_embeddings.py)
"""

import argparse
import json
import os
import re
import sys
import time
import urllib.parse
import urllib.request
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import parse_qs

import numpy as np
import h5py

# ---------------------------------------------------------------------------
# Path setup
# ---------------------------------------------------------------------------

PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, PROJECT_ROOT)

from src.mechanics.vocabulary import Mechanic  # noqa: E402

# ---------------------------------------------------------------------------
# Database loading
# ---------------------------------------------------------------------------

DB_PATH = os.path.join(PROJECT_ROOT, "data", "card_mechanics_commander.h5")

print("Loading card database...")
with h5py.File(DB_PATH, "r") as f:
    MECHANICS = f["mechanics"][:]
    PARAMETERS = f["parameters"][:]
    CARD_INDEX = json.loads(f.attrs["card_index"])
    DB_VOCAB_SIZE = int(f.attrs["vocab_size"])
    PARAM_KEYS = json.loads(f.attrs.get("param_keys", "[]"))

IDX_TO_NAME = {v: k for k, v in CARD_INDEX.items()}

# Build reverse mechanic index → name for the DB vocab size
MECHANIC_NAMES = {}
for m in Mechanic:
    if m.value < DB_VOCAB_SIZE:
        MECHANIC_NAMES[m.value] = m.name

print(f"Loaded {len(CARD_INDEX):,} cards (vocab_size={DB_VOCAB_SIZE})")


# ---------------------------------------------------------------------------
# Scryfall helpers (for card metadata lookup)
# ---------------------------------------------------------------------------

SCRYFALL_NAMED_URL = "https://api.scryfall.com/cards/named"
_scryfall_cache: dict[str, dict] = {}


def scryfall_card_info(name: str) -> dict | None:
    """Fetch card info from Scryfall (cached). Returns dict with image_uri, type_line, oracle_text, mana_cost."""
    if name in _scryfall_cache:
        return _scryfall_cache[name]

    url = f"{SCRYFALL_NAMED_URL}?exact={urllib.parse.quote(name)}"
    try:
        req = urllib.request.Request(url, headers={"User-Agent": "MTG-CardRecommender/1.0"})
        with urllib.request.urlopen(req) as resp:
            card = json.loads(resp.read().decode())
    except Exception:
        _scryfall_cache[name] = None
        return None

    image_uri = ""
    oracle_text = card.get("oracle_text", "")
    type_line = card.get("type_line", "")
    mana_cost = card.get("mana_cost", "")

    if "card_faces" in card and card["card_faces"]:
        front = card["card_faces"][0]
        image_uri = front.get("image_uris", {}).get("normal", "")
        oracle_text = front.get("oracle_text", oracle_text)
        type_line = front.get("type_line", type_line)
        mana_cost = front.get("mana_cost", mana_cost)

    if not image_uri:
        image_uri = card.get("image_uris", {}).get("normal", "")

    info = {
        "name": name,
        "image_uri": image_uri,
        "type_line": type_line,
        "oracle_text": oracle_text,
        "mana_cost": mana_cost,
        "scryfall_uri": card.get("scryfall_uri", ""),
    }
    _scryfall_cache[name] = info
    return info


def batch_scryfall_lookup(names: list[str]) -> list[dict]:
    """Look up card info for a batch, with rate limiting."""
    results = []
    for name in names:
        info = scryfall_card_info(name)
        results.append(info or {"name": name, "image_uri": "", "type_line": "", "oracle_text": "", "mana_cost": "", "scryfall_uri": ""})
        if name not in _scryfall_cache or _scryfall_cache.get(name) is None:
            time.sleep(0.105)  # Scryfall rate limit
    return results


# ---------------------------------------------------------------------------
# Decklist parser
# ---------------------------------------------------------------------------

def parse_decklist(text: str) -> dict:
    """
    Parse decklist from Moxfield, Archidekt, Arena, MTGGoldfish formats.

    Supports:
    - "1 Card Name"
    - "1x Card Name"
    - "1 Card Name (SET) 123"
    - "1 Card Name (SET) *F*" (foil)
    - Section headers: Commander, Deck, Sideboard, Companion
    """
    lines = text.strip().split("\n")
    result = {"mainboard": [], "sideboard": [], "commander": []}
    current_section = "mainboard"

    section_names = {
        "sideboard": "sideboard", "sideboard:": "sideboard",
        "commander": "commander", "commander:": "commander",
        "companion": "sideboard", "companion:": "sideboard",
        "deck": "mainboard", "deck:": "mainboard",
        "mainboard": "mainboard", "mainboard:": "mainboard",
    }

    for line in lines:
        line = line.strip()
        if not line or line.startswith("//") or line.startswith("#"):
            continue

        lower = line.lower()
        if lower in section_names:
            current_section = section_names[lower]
            continue

        match = re.match(
            r"^(\d+)x?\s+([^(]+?)(?:\s+\([^)]+\))?(?:\s+\d+[a-z]?)?(?:\s+\*[FE]\*)?$",
            line,
        )
        if match:
            qty = int(match.group(1))
            card_name = match.group(2).strip()
            result[current_section].append((qty, card_name))

    return result


# ---------------------------------------------------------------------------
# Recommendation engine
# ---------------------------------------------------------------------------

def get_mechanics_for_card(card_name: str) -> list[str]:
    """Get list of mechanic names for a card from the HDF5 matrix."""
    idx = CARD_INDEX.get(card_name)
    if idx is None:
        return []
    vec = MECHANICS[idx]
    return [MECHANIC_NAMES[i] for i in range(len(vec)) if vec[i] and i in MECHANIC_NAMES]


def recommend_cards(
    deck_cards: list[str],
    mode: str = "centroid",
    limit: int = 9,
    exclude_basics: bool = True,
) -> tuple[list[dict], list[str], list[str]]:
    """
    Recommend cards based on a decklist using Jaccard similarity.

    Returns:
        (recommendations, found_cards, missing_cards)
        Each recommendation is {name, score, mechanics}
    """
    BASIC_LANDS = {"Plains", "Island", "Swamp", "Mountain", "Forest",
                   "Snow-Covered Plains", "Snow-Covered Island",
                   "Snow-Covered Swamp", "Snow-Covered Mountain",
                   "Snow-Covered Forest", "Wastes"}

    deck_vecs = []
    found_cards = []
    missing_cards = []

    for card in deck_cards:
        if card in CARD_INDEX:
            deck_vecs.append(MECHANICS[CARD_INDEX[card]])
            found_cards.append(card)
        else:
            missing_cards.append(card)

    if not deck_vecs:
        return [], found_cards, missing_cards

    deck_vecs = np.array(deck_vecs)

    # Pre-compute mechanics counts for filtering
    mech_counts = MECHANICS.sum(axis=1)

    if mode == "centroid":
        # Cosine similarity on continuous centroid (not binarized)
        # This naturally weights frequently-appearing mechanics higher
        centroid = deck_vecs.mean(axis=0).astype(np.float64)
        centroid_norm = np.sqrt((centroid ** 2).sum())
        if centroid_norm < 1e-8:
            scores = np.zeros(len(MECHANICS))
        else:
            mech_float = MECHANICS.astype(np.float64)
            card_norms = np.sqrt((mech_float ** 2).sum(axis=1))
            dots = mech_float @ centroid
            scores = dots / (card_norms * centroid_norm + 1e-8)
            # Penalize cards with very few mechanics (< 3) to avoid trivial matches
            scores[mech_counts < 3] *= 0.3

    elif mode == "gap":
        deck_union = np.logical_or.reduce(deck_vecs).astype(np.uint8)
        gap_score = (MECHANICS & ~deck_union).sum(axis=1).astype(np.float64)
        overlap_score = (MECHANICS & deck_union).sum(axis=1).astype(np.float64)
        scores = 0.3 * overlap_score + 0.7 * gap_score
        # Penalize sparse cards
        scores[mech_counts < 3] *= 0.3

    else:  # alternatives — find cards most similar to the first card
        query_vec = deck_vecs[0]
        intersection = (MECHANICS & query_vec).sum(axis=1)
        union = (MECHANICS | query_vec).sum(axis=1)
        scores = intersection.astype(np.float64) / (union.astype(np.float64) + 1e-8)

    # Exclude deck cards
    for card in found_cards:
        scores[CARD_INDEX[card]] = 0

    # Exclude basic lands
    if exclude_basics:
        for name in BASIC_LANDS:
            if name in CARD_INDEX:
                scores[CARD_INDEX[name]] = 0

    # Exclude cards with zero mechanics (lands, etc.)
    scores[mech_counts == 0] = 0

    top_idx = np.argsort(-scores)[:limit]
    recommendations = []
    for idx in top_idx:
        if scores[idx] <= 0:
            break
        name = IDX_TO_NAME[idx]
        mechanics = get_mechanics_for_card(name)
        recommendations.append({
            "name": name,
            "score": float(scores[idx]),
            "mechanics": mechanics,
        })

    return recommendations, found_cards, missing_cards


# ---------------------------------------------------------------------------
# HTML templates
# ---------------------------------------------------------------------------

HTML_PAGE = r"""<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>MTG Card Recommender</title>
<style>
  :root {
    --bg: #1a1a2e;
    --card-bg: #16213e;
    --card-border: #0f3460;
    --accent: #e94560;
    --good: #00b894;
    --bad: #e17055;
    --text: #eee;
    --text-muted: #999;
    --tag-bg: #0f3460;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
  }
  header {
    text-align: center;
    padding: 24px 16px 12px;
  }
  header h1 { font-size: 1.6rem; font-weight: 700; }
  header p { color: var(--text-muted); font-size: 0.85rem; margin-top: 4px; }

  .container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 0 16px 24px;
  }

  /* Form */
  .form-panel {
    background: var(--card-bg);
    border: 2px solid var(--card-border);
    border-radius: 12px;
    padding: 24px;
    margin-bottom: 20px;
  }
  .form-panel h2 {
    font-size: 1.1rem;
    margin-bottom: 12px;
  }
  textarea {
    width: 100%;
    height: 200px;
    padding: 12px;
    border: 1px solid #2d3a5a;
    border-radius: 8px;
    background: #0d1b2a;
    color: var(--text);
    font-family: 'SF Mono', 'Fira Code', monospace;
    font-size: 0.85rem;
    resize: vertical;
  }
  textarea::placeholder { color: #555; }
  textarea:focus { outline: none; border-color: var(--accent); }

  .modes {
    display: flex;
    gap: 16px;
    margin: 16px 0;
    flex-wrap: wrap;
  }
  .mode-option {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    cursor: pointer;
    padding: 10px 14px;
    background: #0d1b2a;
    border: 2px solid transparent;
    border-radius: 8px;
    transition: all 0.15s;
    flex: 1;
    min-width: 200px;
  }
  .mode-option:hover { border-color: #2d3a5a; }
  .mode-option.selected { border-color: var(--accent); background: #1a1030; }
  .mode-option input[type="radio"] { display: none; }
  .mode-title { font-weight: 700; font-size: 0.9rem; }
  .mode-desc { font-size: 0.75rem; color: var(--text-muted); margin-top: 2px; }

  .submit-btn {
    padding: 12px 36px;
    border-radius: 8px;
    border: none;
    background: var(--accent);
    color: #fff;
    font-size: 1rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.15s;
  }
  .submit-btn:hover { transform: scale(1.03); opacity: 0.9; }
  .submit-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

  /* Stats bar */
  .stats-bar {
    display: flex;
    justify-content: center;
    gap: 24px;
    padding: 8px 16px 16px;
    font-size: 0.85rem;
    color: var(--text-muted);
  }
  .stats-bar span { font-weight: 600; color: var(--text); }

  /* Card grid */
  .grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 14px;
  }
  @media (max-width: 1100px) { .grid { grid-template-columns: repeat(2, 1fr); } }
  @media (max-width: 700px) { .grid { grid-template-columns: 1fr; } }

  .card {
    background: var(--card-bg);
    border: 2px solid var(--card-border);
    border-radius: 12px;
    overflow: hidden;
    transition: border-color 0.2s, transform 0.15s;
    display: flex;
    flex-direction: column;
  }
  .card:hover { transform: translateY(-2px); border-color: var(--accent); }

  .card-top {
    display: flex;
    gap: 12px;
    padding: 12px;
    align-items: flex-start;
  }
  .card-img-wrap {
    position: relative;
    width: 130px;
    min-width: 130px;
  }
  .card-img {
    width: 130px;
    border-radius: 8px;
    transition: transform 0.2s;
  }
  .card-img:hover { transform: scale(1.05); }
  .card-img-placeholder {
    width: 130px;
    height: 181px;
    background: #0d1b2a;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
    font-size: 0.7rem;
  }
  .card-info { flex: 1; min-width: 0; }
  .card-name {
    font-weight: 700;
    font-size: 0.95rem;
    margin-bottom: 2px;
  }
  .card-name a { color: var(--text); text-decoration: none; }
  .card-name a:hover { text-decoration: underline; }
  .card-type { font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px; }
  .card-mana { font-size: 0.75rem; color: #c4a7e7; margin-bottom: 6px; }
  .card-oracle {
    font-size: 0.72rem;
    color: #ccc;
    line-height: 1.4;
    max-height: 80px;
    overflow-y: auto;
    white-space: pre-wrap;
    padding-right: 4px;
  }

  .card-bottom {
    padding: 0 12px 12px;
    flex: 1;
    display: flex;
    flex-direction: column;
  }

  /* Score bar */
  .score-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
  }
  .score-bar-track {
    flex: 1;
    height: 6px;
    background: #2d3a5a;
    border-radius: 3px;
    overflow: hidden;
  }
  .score-bar-fill {
    height: 100%;
    border-radius: 3px;
    background: var(--good);
    transition: width 0.3s;
  }
  .score-label { font-size: 0.75rem; font-weight: 600; min-width: 36px; text-align: right; color: var(--good); }

  /* Mechanics tags */
  .mechanics-list {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin-bottom: 8px;
  }
  .mech-tag {
    display: inline-block;
    background: var(--tag-bg);
    color: #8ecae6;
    font-size: 0.6rem;
    font-weight: 600;
    padding: 2px 6px;
    border-radius: 4px;
    white-space: nowrap;
  }

  .rank-badge {
    position: absolute;
    top: -4px;
    left: -4px;
    width: 24px;
    height: 24px;
    background: var(--accent);
    color: #fff;
    font-size: 0.7rem;
    font-weight: 700;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1;
  }

  /* Warning */
  .warning {
    background: rgba(255, 193, 7, 0.1);
    border: 1px solid rgba(255, 193, 7, 0.3);
    padding: 10px 14px;
    border-radius: 8px;
    margin-bottom: 16px;
    font-size: 0.85rem;
    color: #ffc107;
  }

  /* Loading */
  .loading {
    text-align: center;
    padding: 60px 16px;
    font-size: 1rem;
    color: var(--text-muted);
  }
  .spinner {
    display: inline-block;
    width: 28px; height: 28px;
    border: 3px solid #2d3a5a;
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    margin-bottom: 12px;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* Back link */
  .back-link {
    display: inline-block;
    margin-top: 16px;
    color: var(--accent);
    text-decoration: none;
    font-weight: 600;
    font-size: 0.9rem;
  }
  .back-link:hover { text-decoration: underline; }

  /* Info footer */
  .info-panel {
    background: var(--card-bg);
    border: 2px solid var(--card-border);
    border-radius: 12px;
    padding: 20px 24px;
    margin-top: 20px;
    font-size: 0.82rem;
    color: var(--text-muted);
    line-height: 1.6;
  }
  .info-panel strong { color: var(--text); }
</style>
</head>
<body>
__BODY__
</body>
</html>"""


def _mana_symbols_html(mana_cost: str) -> str:
    """Convert {W}{U}{B} mana cost to plain text (no images needed)."""
    if not mana_cost:
        return ""
    return mana_cost


def _card_html(card_info: dict, rank: int, score: float, mechanics: list[str]) -> str:
    """Render a single recommendation card in the grid."""
    name = card_info.get("name", "Unknown")
    image_uri = card_info.get("image_uri", "")
    type_line = card_info.get("type_line", "")
    oracle_text = card_info.get("oracle_text", "")
    mana_cost = card_info.get("mana_cost", "")
    scryfall_uri = card_info.get("scryfall_uri", "")

    # Image or placeholder
    if image_uri:
        img_html = f'<img class="card-img" src="{image_uri}" alt="{name}" loading="lazy">'
    else:
        img_html = '<div class="card-img-placeholder">No image</div>'

    # Score percentage
    score_pct = min(score * 100, 100)

    # Mechanics tags (limit to 8 most interesting)
    skip_mechanics = {"TRIGGERED_ABILITY", "ACTIVATED_ABILITY", "SORCERY_SPEED", "INSTANT_SPEED"}
    filtered = [m for m in mechanics if m not in skip_mechanics][:8]
    tags_html = "".join(f'<span class="mech-tag">{m}</span>' for m in filtered)

    # Oracle text (escape HTML)
    oracle_escaped = (oracle_text
                      .replace("&", "&amp;")
                      .replace("<", "&lt;")
                      .replace(">", "&gt;"))

    name_escaped = name.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
    type_escaped = type_line.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")

    link = f'<a href="{scryfall_uri}" target="_blank">{name_escaped}</a>' if scryfall_uri else name_escaped

    return f"""
    <div class="card">
      <div class="card-top">
        <div class="card-img-wrap">
          <div class="rank-badge">{rank}</div>
          {img_html}
        </div>
        <div class="card-info">
          <div class="card-name">{link}</div>
          <div class="card-type">{type_escaped}</div>
          <div class="card-mana">{_mana_symbols_html(mana_cost)}</div>
          <div class="card-oracle">{oracle_escaped}</div>
        </div>
      </div>
      <div class="card-bottom">
        <div class="score-row">
          <div class="score-bar-track">
            <div class="score-bar-fill" style="width:{score_pct:.0f}%"></div>
          </div>
          <div class="score-label">{score:.3f}</div>
        </div>
        <div class="mechanics-list">{tags_html}</div>
      </div>
    </div>"""


# ---------------------------------------------------------------------------
# Request handler
# ---------------------------------------------------------------------------

class RecommenderHandler(BaseHTTPRequestHandler):
    def log_message(self, fmt, *args):
        pass  # Suppress default logging

    def do_GET(self):
        if self.path == "/":
            self._serve_form()
        elif self.path == "/api/health":
            self._json_response({"status": "ok", "cards": len(CARD_INDEX), "vocab_size": DB_VOCAB_SIZE})
        else:
            self.send_error(404)

    def do_POST(self):
        content_length = int(self.headers.get("Content-Length", 0))
        body = self.rfile.read(content_length).decode()

        if self.path == "/":
            params = parse_qs(body)
            decklist = params.get("decklist", [""])[0]
            mode = params.get("mode", ["centroid"])[0]
            self._serve_results(decklist, mode)
        elif self.path == "/api/recommend":
            try:
                data = json.loads(body)
                decklist = data.get("decklist", "")
                mode = data.get("mode", "centroid")
                limit = data.get("limit", 9)
            except json.JSONDecodeError:
                self._json_response({"error": "Invalid JSON"}, 400)
                return
            self._api_recommend(decklist, mode, limit)
        else:
            self.send_error(404)

    def _json_response(self, data: dict, status: int = 200):
        self.send_response(status)
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        self.wfile.write(json.dumps(data).encode())

    def _html_response(self, body_html: str):
        self.send_response(200)
        self.send_header("Content-Type", "text/html; charset=utf-8")
        self.end_headers()
        html = HTML_PAGE.replace("__BODY__", body_html)
        self.wfile.write(html.encode())

    def _serve_form(self):
        body = f"""
        <header>
          <h1>MTG Card Recommender</h1>
          <p>Paste your decklist below to get mechanics-based card suggestions.</p>
        </header>

        <div class="container">
          <div class="form-panel">
            <h2>Your Decklist</h2>
            <form method="POST" id="deck-form">
              <textarea name="decklist" id="decklist" placeholder="Paste your decklist here...

Example (Moxfield/Archidekt format):
1 Sol Ring
1 Command Tower
1 Arcane Signet
1 Rhystic Study
1 Swords to Plowshares
1 Counterspell
1 Lightning Bolt
1 Cultivate
1 Beast Within"></textarea>

              <div class="modes" id="modes">
                <label class="mode-option selected" onclick="selectMode(this)">
                  <input type="radio" name="mode" value="centroid" checked>
                  <div>
                    <div class="mode-title">Similar to Deck</div>
                    <div class="mode-desc">Cards that match your deck's overall mechanics profile</div>
                  </div>
                </label>
                <label class="mode-option" onclick="selectMode(this)">
                  <input type="radio" name="mode" value="gap">
                  <div>
                    <div class="mode-title">Fill Gaps</div>
                    <div class="mode-desc">Cards that add new mechanics your deck is missing</div>
                  </div>
                </label>
                <label class="mode-option" onclick="selectMode(this)">
                  <input type="radio" name="mode" value="alternatives">
                  <div>
                    <div class="mode-title">Alternatives</div>
                    <div class="mode-desc">Substitutes for the first card in your list</div>
                  </div>
                </label>
              </div>

              <button type="submit" class="submit-btn" id="submit-btn">Get Recommendations</button>
            </form>
          </div>

          <div class="info-panel">
            <strong>Database:</strong> {len(CARD_INDEX):,} Commander-legal cards |
            <strong>Vocabulary:</strong> {DB_VOCAB_SIZE} mechanics primitives |
            <strong>Similarity:</strong> Jaccard index on binary mechanics vectors
          </div>
        </div>

        <script>
          function selectMode(el) {{
            document.querySelectorAll('.mode-option').forEach(m => m.classList.remove('selected'));
            el.classList.add('selected');
            el.querySelector('input').checked = true;
          }}
        </script>"""
        self._html_response(body)

    def _serve_results(self, decklist: str, mode: str):
        t0 = time.time()

        # Parse decklist
        parsed = parse_decklist(decklist)
        all_cards = []
        for section in ["commander", "mainboard", "sideboard"]:
            for qty, card in parsed[section]:
                all_cards.append(card)

        if not all_cards:
            self._html_response("""
            <header>
              <h1>MTG Card Recommender</h1>
              <p>No cards found in decklist. Check your format and try again.</p>
            </header>
            <div class="container">
              <a class="back-link" href="/">&larr; Back to form</a>
            </div>""")
            return

        # Get recommendations
        recommendations, found_cards, missing_cards = recommend_cards(
            all_cards, mode=mode, limit=9
        )

        # Fetch card info from Scryfall for the recommendations
        rec_names = [r["name"] for r in recommendations]
        print(f"  Fetching {len(rec_names)} card images from Scryfall...")
        card_infos = batch_scryfall_lookup(rec_names)

        elapsed = time.time() - t0

        mode_names = {
            "centroid": "Similar to Deck",
            "gap": "Fill Gaps",
            "alternatives": "Card Alternatives",
        }

        # Build stats bar
        stats_html = f"""
        <div class="stats-bar">
          <div>Mode: <span>{mode_names.get(mode, mode)}</span></div>
          <div>Deck cards: <span>{len(all_cards)}</span></div>
          <div>Found: <span style="color:var(--good)">{len(found_cards)}</span></div>
          <div>Missing: <span style="color:var(--bad)">{len(missing_cards)}</span></div>
          <div>Time: <span>{elapsed:.1f}s</span></div>
        </div>"""

        # Missing cards warning
        warning_html = ""
        if missing_cards:
            names = ", ".join(missing_cards[:10])
            more = f" ... and {len(missing_cards) - 10} more" if len(missing_cards) > 10 else ""
            warning_html = f'<div class="warning">Cards not found in database: {names}{more}</div>'

        # Build card grid
        grid_html = '<div class="grid">'
        for i, (rec, info) in enumerate(zip(recommendations, card_infos)):
            grid_html += _card_html(info, i + 1, rec["score"], rec["mechanics"])
        grid_html += "</div>"

        body = f"""
        <header>
          <h1>Recommendations</h1>
          <p>{mode_names.get(mode, mode)} — {len(recommendations)} cards found</p>
        </header>

        {stats_html}

        <div class="container">
          {warning_html}
          {grid_html}
          <a class="back-link" href="/">&larr; Try another decklist</a>
        </div>"""

        self._html_response(body)
        print(f"  Served {len(recommendations)} recommendations in {elapsed:.1f}s")

    def _api_recommend(self, decklist: str, mode: str, limit: int):
        parsed = parse_decklist(decklist)
        all_cards = []
        for section in ["commander", "mainboard", "sideboard"]:
            for qty, card in parsed[section]:
                all_cards.append(card)

        recommendations, found_cards, missing_cards = recommend_cards(
            all_cards, mode=mode, limit=limit
        )

        self._json_response({
            "recommendations": recommendations,
            "found_cards": found_cards,
            "missing_cards": missing_cards,
            "deck_size": len(all_cards),
        })


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(description="MTG Card Recommender Server")
    parser.add_argument("--port", type=int, default=8000, help="Port (default: 8000)")
    args = parser.parse_args()

    print(f"\n{'=' * 60}")
    print("MTG Card Recommender Server")
    print(f"{'=' * 60}")
    print(f"Cards: {len(CARD_INDEX):,}")
    print(f"Vocab: {DB_VOCAB_SIZE}")
    print(f"Memory: {MECHANICS.nbytes / 1024 / 1024:.1f} MB")
    print(f"\nServer running at http://localhost:{args.port}")
    print("Press Ctrl+C to stop")
    print(f"{'=' * 60}\n")

    server = HTTPServer(("localhost", args.port), RecommenderHandler)
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("\n\nShutting down...")
        server.shutdown()


if __name__ == "__main__":
    main()
